{
  "SecuritySmells": [
    {
      "code": "UPM",
      "name": "Unnecessary Privileges to Microservices",
      "securityPropertiesAffected": [
        "Confidentiality",
        "Integrity"
      ],
      "description": "The Unnecessary Privileges to Microservices smell occurs when microservices are granted unnecessary access levels, permissions, or functionalities that are actually not needed by such microservices to deliver their business functions. The additional privileges given to microservices would potentially result in Confidentiality and Integrity issues. This happens, e.g., when a service can write or read data stored in databases or messages posted in messages queues, even if such databases or queues are not needed by the service to deliver its business function. As a result, resources are unnecessarily exposed, hence unnecessarily increasing the attack surface for Confidentiality and Integrity leaks: an intruder taking control of a service can indeed start reading or modifying all data and messages the service can access to.",
      "refactoring": "The Least Privilege Principle recommends that accounts and services should have the least amount of privileges they need to suitably perform their business function. This principle should be used because even if a development team has ensured that the machine-to-machine communication is secured and there are appropriate safeguards with their firewall, there is always the risk that an attacker gets access to the microservice-based application. Development teams should indeed limit service privileges, by providing each service with access to only the resources they actually need to deliver their business functionalities."
    },
    {
      "code": "IAC",
      "name": "Insufficient Access Control",
      "securityPropertiesAffected": [
        "Confidentiality"
      ],
      "description": "The Insufficient Access Control smell occurs whenever a microservice-based application does not enact access control in one or more of its microservices, hence possibly violating the Confidentiality of the data and business functions of the microservices where access control is lacking. If this smell is present, microservices can get exposed to, eg the confused deputy problem, with attackers that can trick a service and get data that they should not be able to get. At the same time, microservices are not suitable for traditional identity control models, since client details and permissions need to be verified as and when a request is sent, and they need a way to automatically decide whether to allow or reject calls between services. In addition, microservices require development teams to establish and maintain the identity of users without introducing extra latency and contention with frequent calls to a centralized service.",
      "refactoring": "The effects of this smell can be mitigated if development teams use OAuth 2.0. Open Authorization (OAuth) 2.0 is the most used mechanism to manage access delegation. OAuth 2.0 is a token-based security framework for delegated access control that lets a resource owner grant a client access to a particular resource on their behalf. This access is for a limited time and with limited scope. OAuth 2.0 is hence a natural candidate to enforce access control in a microservice-based application at each level, therein including controlling the accesses to each microservice."
    },
    {
      "code": "CA",
      "name": "Centralized Authorization",
      "securityPropertiesAffected": [
        "Authenticity"
      ],
      "description": "In a microservice-based application, authorization can be enforced at the “edge” of the application (e.g., with the API gateway), by each microservice of the application, or both. The Centralized Authorization smell occurs when the microservice-based application only handles authorization in one component, typically at the “edge” of the application, while it does not enact any fine-grained authorization control at the microservices level. Such a kind of centralized authorization diminishes the advantages of having a distributed solution, such as that given by microservices, and it reduces performance and efficiency since the central authorization point tends to become a bottleneck. A Centralized Authorization may also result in violating Authenticity in microservice-based applications. For instance, when authorization is managed only at the edge, microservices are exposed to the so-called “confused deputy problem”: they trust the gateway based on its mere identity, exposing the microservices in an application to misuse if they are compromised. It is worth noting that the “confused deputy problem” here occurs in a different way from when there is Insufficient Access Control, as here a centralized authorization results in an invoked microservice trusting its invoker without enacting any further authorization. In the case of Insufficient Access Control, instead, it is the invoker that has access to too many resources, hence potentially exposing such resources to attacks.",
      "refactoring": "Development teams can refactor the microservice-based application to mitigate the Centralized Authorization smell by enacting a decentralized authorization approach. They can indeed Use Decentralized Authorization by simply developing a token-based authorization mechanism. This is achieved by transmitting an access token together with each request to a microservice, and access to such microservice is granted to the caller only if a known and correct token is passed. In this way, authorization can be enforced also at the microservices level, as it gives each microservice more control to enforce its own access-control policies. JSON Web Token (JWT) is the most used mechanism to implement such refactoring. A JWT is a standard for safely passing claims or data attributed to a user within an environment, which ensures that a man in the middle cannot change its content because the issuer of the JWT actually signs it."
    }
  ]
}
